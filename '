package day3

import (
	"fmt"
	"log"
	"os"
	"regexp"
	"strconv"

	"github.com/arturfil/go_aoc/helpers"
)

func PartOneAlt() {

	file, _ := helpers.ReadInput("./day3/input.txt")

	// pattern := `mul\(\d{1,3},\d{1,3}\)`
	// pattern := `mul\((\d{1,3}),(\d{1,3})\)`
    
	pattern := `(do\(\)|don't\(\))|mul\((\d+),(\d+)\)`

	re := regexp.MustCompile(pattern)

    var matches [][]string 
    for _, line := range file {
        match := re.FindAllStringSubmatch(line, -1)
        fmt.Println("match -> \n", match)
        matches = append(matches, match...)
    }


    // totScore := 0
    // enabled := true
    // for _, match := range matches {
    //     
    //     if match[1] == "don't()" {
    //         enabled = false
    //         continue
    //     }
    //     if match[1] == "do()" {
    //         enabled = true
    //         continue
    //     }

    //     if enabled {
    //         n1, _ := strconv.Atoi(match[2])
    //         n2, _ := strconv.Atoi(match[3])

    //         totScore += n1 * n2
    //     }
    // }

    // fmt.Println("totScore", totScore)
}

func PartOne() {

	file, err := os.ReadFile("./day3/input.txt")
	if err != nil {
		log.Fatal(err)
		return
	}

	pattern := `mul\(\d{1,3},\d{1,3}\)`
	re := regexp.MustCompile(pattern)
	matches := re.FindAllString(string(file), -1)

	totScore := calculate(matches)
	fmt.Println("tot score:", totScore)
}

func PartTwo() {

	file, err := helpers.ReadInput("./day3/input.txt")
	if err != nil {
		log.Fatal(err)
		return
	}

	validPattern := `(do\(\)|don't\(\))|mul\((\d+),(\d+)\)`
    re := regexp.MustCompile(validPattern)

    // find all matches in sample
    var matches [][]string
    for _, line := range file {
        match := re.FindAllStringSubmatch(line, -1)
        matches = append(matches, match...)
    }

    totScore := 0
    enabled := true

    for _, match := range matches {
        
        if match[1] == "don't()" {
            enabled = false
            continue
        }
        if match[1] == "do()" {
            enabled = true
            continue
        }

        if enabled {
            n1, _ := strconv.Atoi(match[2])
            n2, _ := strconv.Atoi(match[3])

            totScore += n1 * n2
        }
    }

    fmt.Println("Tot Score:", totScore)

}

func calculate(matches [][]string) int {
	var totScore int

    enabled := true
	for _, match := range matches {

        if match[1] == "don't()" && isControlled {
            enabled = false
            continue
        }
        if match[1] == "do()" && isControlled {
            enabled = true
            continue
        }

        if enabled {
            n1, _ := strconv.Atoi(match[2])
            n2, _ := strconv.Atoi(match[3])

            totScore += n1 * n2
        }
	}

	return totScore
}
